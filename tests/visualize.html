<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <title>Line Candidates Visualizer — All Geometry</title>
  <!-- jsPDF for exporting canvases to PDF -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@3.0.3/dist/jspdf.umd.min.js"></script>
  <style>
    html,
    body {
      height: 100%;
      overflow: hidden;
      /* 不让窗口本身出现滚动条 */
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft Yahei";
      margin: 0;
      padding: 12px;
      display: flex;
      flex-direction: column;
      height: 100vh;
      /* 明确指定占满视口 */
    }

    h2 {
      margin: 0 0 8px;
    }

    #headerTitle {
      font-size: 14px;
      font-weight: 500;
      line-height: 1.25;
    }

    #container {
      display: flex;
      gap: 12px;
      align-items: stretch;
      flex: 1 1 auto;
      min-height: 0;
      /* 允许内部子元素计算高度并滚动 */
      overflow: hidden;
      /* 容器自身不产生滚动条 */
    }

    #canvasWrap {
      border: 1px solid #ddd;
      position: relative;
      overflow: auto;
      /* 只在左侧区域出现滚动条 */
      height: 100%;
      flex: 1 1 auto;
      /* 随容器拉伸，优先占据剩余宽度 */
      min-width: 0;
      /* 允许在狭窄视口中收缩，避免页面产生水平滚动条 */
    }

    canvas {
      background: #fff;
      display: block;
      /* 初始尺寸由脚本设置，CSS 层面允许它跟随容器伸展（缩放的是显示像素，不改 canvas.width/height 内部分辨率） */
    }

    #legend {
      width: 360px;
      height: 100%;
      overflow: auto;
      /* 只在右侧 Legend 出滚动条 */
      padding: 10px;
      border: 1px solid #eee;
      flex: 0 0 360px;
      /* 固定宽度，不参与压缩 */
      scroll-behavior: smooth;
    }

    #splitter {
      width: 6px;
      flex: 0 0 6px;
      cursor: col-resize;
      background: linear-gradient(180deg, #e4e7eb, #d5d9de);
      border: 1px solid #d0d4d9;
      box-sizing: border-box;
      position: relative;
    }

    #splitter::after {
      content: '';
      position: absolute;
      inset: 0;
      left: 50%;
      width: 2px;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.08);
    }

    #splitter.dragging {
      background: linear-gradient(180deg, #c8d3e0, #b7c2ce);
    }

    .part-row {
      margin-bottom: 10px;
    }

    .color-swatch {
      width: 28px;
      height: 14px;
      display: inline-block;
      vertical-align: middle;
      margin-right: 8px;
      border: 1px solid rgba(0, 0, 0, 0.08);
    }

    .legend-title {
      font-weight: 600;
      margin-bottom: 8px;
    }

    .legend-section-title {
      font-size: 13px;
      font-weight: 600;
      color: #666;
      margin: 14px 0 6px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 6px 8px;
      font-size: 12px;
      border-radius: 4px;
      transform: translate(10px, 10px);
      white-space: nowrap;
      display: none;
      z-index: 10;
    }

    .controls {
      margin: 0 0 8px;
    }

    .layer-toggle {
      margin-right: 8px;
    }

    .part-row {
      padding: 6px 8px;
      border-radius: 6px;
      cursor: pointer;
      /* 可点击 */
      transition: background 0.15s ease, box-shadow 0.15s ease;
    }

    .part-row:hover {
      background: #fafafa;
    }

    .part-row.active {
      background: #eef6ff;
      box-shadow: inset 0 0 0 1px #b6daff;
    }

    .part-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .part-name {
      font-weight: 600;
    }

    .part-meta {
      font-size: 12px;
      color: #666;
    }

    .chip {
      display: inline-block;
      padding: 1px 6px;
      border-radius: 10px;
      background: #f2f2f2;
      font-size: 12px;
      margin-left: 6px;
    }

    .row-line {
      margin-top: 6px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .swatch {
      width: 28px;
      height: 12px;
      border: 1px solid rgba(0, 0, 0, 0.08);
    }

    .details-card {
      margin-bottom: 12px;
      padding: 10px;
      border: 1px solid #eee;
      border-radius: 8px;
      background: #fafafa;
      font-size: 12px;
      color: #333;
    }

    .details-card .title {
      font-weight: 700;
      margin-bottom: 6px;
    }

    .details-card .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .sublist {
      margin: 8px 0 0 8px;
      padding-left: 10px;
      border-left: 2px solid #eee;
    }

    .subitem {
      padding: 4px 6px;
      border-radius: 6px;
      cursor: pointer;
    }

    .subitem:hover {
      background: #f5f5f5;
    }

    .subitem.active {
      background: #eef6ff;
      box-shadow: inset 0 0 0 1px #b6daff;
    }

    .sep {
      height: 1px;
      background: #f0f0f0;
      margin: 10px 0;
    }
  </style>
</head>

<body>
  <div id="tabBar" style="display:flex;gap:4px;align-items:stretch;margin:0 0 6px;flex-wrap:wrap;">
    <div id="addTabBtn"
      style="padding:4px 10px;border:1px dashed #bbb;border-radius:6px;font-size:12px;cursor:pointer;color:#666;user-select:none;">
      + 新标签</div>
    <div id="exportPdfBtn"
      style="padding:4px 10px;border:1px solid #5b8;border-radius:6px;font-size:12px;cursor:pointer;color:#276;user-select:none;">
      导出PDF</div>
    <div id="clearTabsBtn"
      style="padding:4px 10px;border:1px solid #e99;border-radius:6px;font-size:12px;cursor:pointer;color:#b22;user-select:none;">
      清空</div>
  </div>
  <h2 id="headerTitle" title="数据概览：动态显示当前 JSON 的名称与对象数量">未加载数据 — 拖拽或粘贴 JSON 以开始</h2>
  <div class="controls">
    <label class="layer-toggle"><input type="checkbox" id="showObstacles" checked /> obstacle_box</label>
    <label class="layer-toggle"><input type="checkbox" id="showBarriers" checked /> barrier_line</label>
    <label class="layer-toggle"><input type="checkbox" id="showTargets" checked /> target_exterior</label>
    <label class="layer-toggle"><input type="checkbox" id="showParts" checked /> part candidates</label>
    <label class="layer-toggle"><input type="checkbox" id="showSolution" checked /> solution</label>
  </div>
  <div id="container">
    <div id="canvasWrap">
      <canvas id="c" width="800" height="600"></canvas>
      <div id="tooltip" class="tooltip"></div>
    </div>
    <div id="splitter" title="拖动调整面板宽度"></div>
    <div id="legend">
      <div class="legend-title">Legend</div>
      <div id="details" class="details-card"></div>
      <div id="legendContent"></div>
    </div>
    <div id="dragOverlay"
      style="display:none;position:fixed;z-index:9999;top:0;left:0;width:100vw;height:100vh;background:rgba(60,120,200,0.18);backdrop-filter:blur(1.5px);color:#235;font-size:28px;font-weight:600;align-items:center;justify-content:center;pointer-events:none;transition:opacity 0.18s;">
      <div style="width:100%;text-align:center;margin-top:20vh;letter-spacing:1px;">松开以导入 JSON 文件</div>
    </div>

    <script>
      // 仅限 canvasWrap 区域的拖拽导入
      const dragOverlay = document.getElementById('dragOverlay');
      const canvasWrapEl = document.getElementById('canvasWrap');
      let dragCounter = 0;
      function showOverlay() { dragOverlay.style.display = 'flex'; dragOverlay.style.opacity = '1'; }
      function hideOverlay() { dragOverlay.style.opacity = '0'; setTimeout(() => { dragOverlay.style.display = 'none'; }, 180); }
      function handleDropFile(ev) {
        ev.preventDefault(); ev.stopPropagation(); dragCounter = 0; hideOverlay();
        const fileList = Array.from(ev.dataTransfer.files || []).filter(f => /\.json$/i.test(f.name));
        if (!fileList.length) { alert('未找到 .json 文件'); return; }
        let idx = 0; (function loadNext() { if (idx >= fileList.length) return; const f = fileList[idx++]; const reader = new FileReader(); reader.onload = () => { try { const json = JSON.parse(String(reader.result)); if (window.__vis?.openNewTab) { window.__vis.openNewTab(json, f.name); } else { setupFromData(json); } } catch (e) { console.error(e); alert('JSON 解析失败: ' + f.name + ' => ' + e.message); } finally { loadNext(); } }; reader.onerror = () => { alert('文件读取失败: ' + f.name); loadNext(); }; reader.readAsText(f, 'utf-8'); })();
      }
      function preventDefault(ev) { ev.preventDefault(); ev.stopPropagation(); }
      ['dragenter', 'dragover'].forEach(evt => { canvasWrapEl.addEventListener(evt, e => { if (!e.dataTransfer) return; if ([...e.dataTransfer.types].includes('Files')) { if (dragCounter++ === 0) showOverlay(); preventDefault(e); } }); });
      ['dragleave', 'drop'].forEach(evt => { canvasWrapEl.addEventListener(evt, e => { if (evt === 'drop') { handleDropFile(e); return; } if (--dragCounter <= 0) { dragCounter = 0; hideOverlay(); } preventDefault(e); }); });
    </script>
  </div>

  <script>
    // ------------------------------
    // Canvas 初始化 & 动态数据装载
    // ------------------------------
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const canvasWrap = document.getElementById('canvasWrap');
    const tooltip = document.getElementById('tooltip');
    const legendContent = document.getElementById('legendContent');
    const headerTitle = document.getElementById('headerTitle');
    const legendRoot = document.getElementById('legend');
    // click/dblclick 协调：延迟单击以区分双击
    let clickTimer = null;
    const CLICK_DELAY = 220; // ms

    // 视图与交互状态（可在加载新 JSON 时复位）
    let isPanning = false;
    let panStartX = 0, panStartY = 0;
    let panX = 0, panY = 0, startPanX = 0, startPanY = 0;
    // 缩放：基于 CSS 大小缩放，保持宽高等比例
    let currentScale = 1;        // 叠加缩放（相对于 baseCssScale）
    let baseCssScale = 1;        // 让原始 canvas 尺寸在 wrapper 中按不失真铺满的基准比例

    // 保持一个“基础坐标系”的画布尺寸（不随 CSS 缩放而变），所有绘制以它为基准。
    const baseCanvasWidth = canvas.width;
    const baseCanvasHeight = canvas.height;
    function getRenderScale() {
      // 当前 CSS 宽度 / 基础画布宽度 = 逻辑缩放（不含设备像素比）
      const rect = canvas.getBoundingClientRect();
      return rect.width / baseCanvasWidth;
    }
    function syncBackingStoreToCss() {
      // 将 backing store 尺寸匹配到 CSS 尺寸 * 设备像素比，保证放大不糊
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const targetW = Math.max(1, Math.round(rect.width * dpr));
      const targetH = Math.max(1, Math.round(rect.height * dpr));
      if (canvas.width !== targetW || canvas.height !== targetH) {
        canvas.width = targetW;
        canvas.height = targetH;
      }
    }

    // 数据与映射（随数据重算）
    let data = null;
    const padding = 20;
    let minX = 0, minY = 0, maxX = 0, maxY = 0;
    let baseScale = 1, offsetX = 0, offsetY = 0;
    let parts = [], pointsParts = [];
    let solutionLines = [];
    let partMeta = [];
    let hoveredPartId = null; // 当前悬浮的 part_id，用于整体高亮
    let selectedPartId = null; // 点击选择的 part_id，类似锁定 hover（仅针对整件）
    let hoveredFocus = null;   // { type: 'part'|'line'|'point', part_id, lineIdx?, pointIdx? }
    let selectedFocus = null;  // 同上，表示锁定选中具体线/点
    // 为避免 legend 在 hover 时被频繁重建，影响 click/dblclick 触发，这里提供一次性抑制 legend 重建的开关
    let suppressLegend = false;
    // 在 legend 鼠标按下到抬起期间，不重建 legend，避免 click 被中途替换 DOM 导致失效
    let isLegendMouseDown = false;

    function toCanvasX(x) { return x * baseScale + offsetX; }
    function toCanvasY(y) { return baseCanvasHeight - (y * baseScale + offsetY); }

    // hash -> hue
    function hueFromString(str) { let h = 0; for (let i = 0; i < str.length; i++) h = (h * 31 + str.charCodeAt(i)) | 0; return Math.abs(h) % 360; }
    function colorForWeight(hue, w, minW, maxW) { const t = (w - minW) / ((maxW - minW) || 1); const sat = 60 + Math.round(30 * t); const light = 60 - Math.round(30 * t); return `hsl(${hue} ${sat}% ${light}%)`; }

    function resetView() {
      // 重置缩放与平移
      currentScale = 1;
      panX = 0; panY = 0;
      // 用基准比例设置 CSS 大小，保持等比
      setCssSize(baseCssScale * currentScale);
      canvas.style.transform = 'translate(0px, 0px)';
      canvasWrap.scrollLeft = 0;
      canvasWrap.scrollTop = 0;
      // 同步 backing store，避免缩放后模糊
      syncBackingStoreToCss();
    }

    function computeBaseCssScale() {
      // 让基础画布尺寸在 wrapper 内完整显示且不变形
      const wrapRect = canvasWrap.getBoundingClientRect();
      const availW = Math.max(50, wrapRect.width - 20);
      const availH = Math.max(50, wrapRect.height - 20);
      const sx = availW / baseCanvasWidth;
      const sy = availH / baseCanvasHeight;
      baseCssScale = Math.max(0.1, Math.min(sx, sy));
    }

    function setCssSize(scale) {
      const w = Math.round(baseCanvasWidth * scale);
      const h = Math.round(baseCanvasHeight * scale);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
    }

    function getCssScale() {
      const rect = canvas.getBoundingClientRect();
      return rect.width / baseCanvasWidth;
    }

    function safeId(val) {
      return String(val ?? 'NA').replace(/[^a-zA-Z0-9_-]+/g, '_');
    }

    // 将 subject 聚焦到视野中心（不改变缩放），subject: {type:'part'|'line'|'point', part_id, lineIdx?, pointIdx?}
    function focusCanvasOn(subject) {
      if (!subject) return;
      const cssScale = getCssScale();
      let targetCanvasX = null, targetCanvasY = null;
      const toCss = (cx) => cx * cssScale;
      const commitCenter = (cxCanvas, cyCanvas) => {
        const cxCss = toCss(cxCanvas);
        const cyCss = toCss(cyCanvas);
        const contentW = canvas.width * cssScale;
        const contentH = canvas.height * cssScale;
        const wrapW = canvasWrap.clientWidth;
        const wrapH = canvasWrap.clientHeight;
        const centerX = wrapW / 2;
        const centerY = wrapH / 2;
        if (contentW > wrapW) {
          const desired = cxCss - centerX;
          const maxScroll = Math.max(0, contentW - wrapW);
          canvasWrap.scrollLeft = Math.max(0, Math.min(desired, maxScroll));
          panX = 0;
        } else {
          canvasWrap.scrollLeft = 0;
          panX = Math.round(centerX - cxCss);
        }
        if (contentH > wrapH) {
          const desired = cyCss - centerY;
          const maxScroll = Math.max(0, contentH - wrapH);
          canvasWrap.scrollTop = Math.max(0, Math.min(desired, maxScroll));
          panY = 0;
        } else {
          canvasWrap.scrollTop = 0;
          panY = Math.round(centerY - cyCss);
        }
        applyPanTransform();
      };

      if (subject.type === 'line') {
        const p = parts.find(pp => pp.part_id === subject.part_id);
        if (!p || !p.lines || !p.lines[subject.lineIdx]) return;
        const s = p.lines[subject.lineIdx].lineSegment;
        const x1 = toCanvasX(s.x1), y1 = toCanvasY(s.y1);
        const x2 = toCanvasX(s.x2), y2 = toCanvasY(s.y2);
        commitCenter((x1 + x2) / 2, (y1 + y2) / 2);
      } else if (subject.type === 'point') {
        const p = pointsParts.find(pp => pp.part_id === subject.part_id);
        if (!p || !p.points || !p.points[subject.pointIdx]) return;
        const pt = p.points[subject.pointIdx];
        commitCenter(toCanvasX(pt.coordinate.x), toCanvasY(pt.coordinate.y));
      } else if (subject.type === 'part') {
        // 计算该部件的包围盒中心
        let minCx = Infinity, minCy = Infinity, maxCx = -Infinity, maxCy = -Infinity;
        const lp = parts.find(pp => pp.part_id === subject.part_id);
        if (lp && lp.lines) {
          for (const it of lp.lines) {
            const s = it.lineSegment;
            minCx = Math.min(minCx, toCanvasX(s.x1), toCanvasX(s.x2));
            maxCx = Math.max(maxCx, toCanvasX(s.x1), toCanvasX(s.x2));
            minCy = Math.min(minCy, toCanvasY(s.y1), toCanvasY(s.y2));
            maxCy = Math.max(maxCy, toCanvasY(s.y1), toCanvasY(s.y2));
          }
        }
        const pp = pointsParts.find(pp => pp.part_id === subject.part_id);
        if (pp && pp.points) {
          for (const pt of pp.points) {
            const cx = toCanvasX(pt.coordinate.x);
            const cy = toCanvasY(pt.coordinate.y);
            minCx = Math.min(minCx, cx); maxCx = Math.max(maxCx, cx);
            minCy = Math.min(minCy, cy); maxCy = Math.max(maxCy, cy);
          }
        }
        if (isFinite(minCx) && isFinite(minCy) && isFinite(maxCx) && isFinite(maxCy)) {
          commitCenter((minCx + maxCx) / 2, (minCy + maxCy) / 2);
        }
      }
    }

    function ensureLegendVisible(subject) {
      if (!subject) return;
      let elId = null;
      if (subject.type === 'line') elId = `legend-part-${safeId(subject.part_id)}-line-${subject.lineIdx}`;
      else if (subject.type === 'point') elId = `legend-part-${safeId(subject.part_id)}-point-${subject.pointIdx}`;
      else if (subject.type === 'part') elId = `legend-part-${safeId(subject.part_id)}`;
      const el = elId ? document.getElementById(elId) : null;
      if (el) {
        el.scrollIntoView({ block: 'nearest', inline: 'nearest' });
      }
    }

    function setupFromData(newData) {
      data = newData || {};
      // 计算边界
      minX = Infinity; minY = Infinity; maxX = -Infinity; maxY = -Infinity;
      const includePoint = (x, y) => { if (x == null || y == null || isNaN(x) || isNaN(y)) return; minX = Math.min(minX, x); minY = Math.min(minY, y); maxX = Math.max(maxX, x); maxY = Math.max(maxY, y); };

      if (Array.isArray(data.obstacle_box)) {
        for (const box of data.obstacle_box) {
          ['a', 'b', 'c', 'd'].forEach(k => { if (box && box[k]) includePoint(box[k].x, box[k].y); });
        }
      }
      if (Array.isArray(data.barrier_line)) {
        for (const l of data.barrier_line) includePoint(l.x1, l.y1), includePoint(l.x2, l.y2);
      }
      if (Array.isArray(data.target_exterior)) {
        for (const p of data.target_exterior) includePoint(p.x, p.y);
      }
      if (data.part) {
        if (Array.isArray(data.part.line_candidates)) {
          for (const p of data.part.line_candidates) {
            for (const item of p.lines || []) includePoint(item.lineSegment.x1, item.lineSegment.y1), includePoint(item.lineSegment.x2, item.lineSegment.y2);
          }
        }
        if (Array.isArray(data.part.point_candidates)) {
          for (const p of data.part.point_candidates) {
            for (const pt of p.points || []) includePoint(pt.coordinate.x, pt.coordinate.y);
          }
        }
      }
      if (data.solution && Array.isArray(data.solution.lines)) {
        for (const sl of data.solution.lines) {
          if (sl && sl.start && sl.end) { includePoint(sl.start.x, sl.start.y); includePoint(sl.end.x, sl.end.y); }
        }
      }
      if (!isFinite(minX)) { minX = 0; minY = 0; maxX = baseCanvasWidth; maxY = baseCanvasHeight; }

      // 统一在 AABB 四周增加 5% 留白（总尺寸放大 5%），避免元素/标签紧贴边缘
      let dataWidth = Math.max(1, maxX - minX);
      let dataHeight = Math.max(1, maxY - minY);
      const expandRatio = 0.05; // 总体放大 5%
      if (isFinite(dataWidth) && isFinite(dataHeight) && dataWidth > 0 && dataHeight > 0) {
        const expandW = dataWidth * expandRatio;
        const expandH = dataHeight * expandRatio;
        minX -= expandW / 2; maxX += expandW / 2;
        minY -= expandH / 2; maxY += expandH / 2;
        dataWidth = Math.max(1, maxX - minX);
        dataHeight = Math.max(1, maxY - minY);
      }
      const baseScaleX = (baseCanvasWidth - padding * 2) / dataWidth;
      const baseScaleY = (baseCanvasHeight - padding * 2) / dataHeight;
      baseScale = Math.min(baseScaleX, baseScaleY);
      offsetX = padding - minX * baseScale + ((baseCanvasWidth - padding * 2) - dataWidth * baseScale) / 2;
      offsetY = padding - minY * baseScale + ((baseCanvasHeight - padding * 2) - dataHeight * baseScale) / 2;

      // 衍生: parts/pointsParts
      parts = (data.part && Array.isArray(data.part.line_candidates)) ? data.part.line_candidates.map(p => {
        const weights = (p.lines || []).map(l => l.weight);
        const minW = weights.length ? Math.min(...weights) : 0;
        const maxW = weights.length ? Math.max(...weights) : 0;
        return { ...p, minW, maxW, hue: hueFromString((p.part_name || '') + (p.part_id ?? '')) };
      }) : [];
      pointsParts = (data.part && Array.isArray(data.part.point_candidates)) ? data.part.point_candidates.map(p => {
        const ws = (p.points || []).map(pt => pt.weight);
        const minW = ws.length ? Math.min(...ws) : 0;
        const maxW = ws.length ? Math.max(...ws) : 0;
        return { ...p, minW, maxW, hue: hueFromString((p.part_name || '') + (p.part_id ?? '')) };
      }) : [];
      solutionLines = (data.solution && Array.isArray(data.solution.lines)) ? data.solution.lines.map((ln, idx) => ({ ...ln, __idx: idx })) : [];

      // 合并 line/point 两类，按 part_id 生成元信息
      const map = new Map();
      const addMeta = (p, type) => {
        const id = p.part_id ?? (p.part_name || '');
        if (!map.has(id)) map.set(id, { part_id: p.part_id, part_name: p.part_name || '', hue: p.hue, lineCount: 0, pointCount: 0, minW: Infinity, maxW: -Infinity });
        const m = map.get(id);
        m.hue = p.hue; // keep last
        if (type === 'line') {
          const cnt = (p.lines || []).length;
          m.lineCount += cnt;
          if (isFinite(p.minW)) m.minW = Math.min(m.minW, p.minW);
          if (isFinite(p.maxW)) m.maxW = Math.max(m.maxW, p.maxW);
        } else if (type === 'point') {
          const cnt = (p.points || []).length;
          m.pointCount += cnt;
          if (isFinite(p.minW)) m.minW = Math.min(m.minW, p.minW);
          if (isFinite(p.maxW)) m.maxW = Math.max(m.maxW, p.maxW);
        }
      };
      for (const p of parts) addMeta(p, 'line');
      for (const p of pointsParts) addMeta(p, 'point');
      partMeta = Array.from(map.values()).map(m => ({ ...m, minW: isFinite(m.minW) ? m.minW : 0, maxW: isFinite(m.maxW) ? m.maxW : 0 }));

      // 重新计算基准 CSS 缩放，并复位视图
      computeBaseCssScale();
      resetView();
      render();
    }

    function updateHeader() {
      if (!headerTitle) return;
      if (!data) {
        headerTitle.textContent = '未加载数据 — 请选择或拖拽 JSON 文件';
        return;
      }
      const schemaName = (typeof data?.schema_name === 'string') ? data.schema_name : '';
      const numBarriers = Array.isArray(data?.barrier_line) ? data.barrier_line.length : 0;
      const numBoxes = Array.isArray(data?.obstacle_box) ? data.obstacle_box.length : 0;
      const numTargetPts = Array.isArray(data?.target_exterior) ? data.target_exterior.length : 0;
      // 统计 parts：按 part_id 聚合
      const partIds = new Set();
      if (data?.part?.line_candidates) for (const p of data.part.line_candidates) partIds.add(p.part_id ?? p.part_name ?? '');
      if (data?.part?.point_candidates) for (const p of data.part.point_candidates) partIds.add(p.part_id ?? p.part_name ?? '');
      const numParts = partIds.size;
      const partsText = `parts: ${numParts}`;
      const targetText = `target_exterior: ${numTargetPts > 0 ? '1' : '0'}（points: ${numTargetPts}）`;
      const solutionCount = Array.isArray(data?.solution?.lines) ? data.solution.lines.length : 0;
      headerTitle.textContent = `${schemaName || '数据'} — ${partsText} · solution: ${solutionCount} · obstacle_box: ${numBoxes} · barrier_line: ${numBarriers} · ${targetText}`;
    }

    // Draw functions
    function render() {
      // 确保 backing store 与 CSS 尺寸一致，并设置绘制变换：设备像素比 * 逻辑缩放
      syncBackingStoreToCss();
      const dpr = window.devicePixelRatio || 1;
      const rs = getRenderScale();
      // 先以设备像素坐标清空，再设置绘制坐标变换
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(dpr * rs, 0, 0, dpr * rs, 0, 0);
      // 无数据时提示选择文件
      if (!data) {
        legendContent.innerHTML = '<div>暂无数据</div>';
        ctx.save();
        ctx.fillStyle = '#666';
        ctx.font = '16px system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('选择 JSON 文件或者拖动文件到此处', baseCanvasWidth / 2, baseCanvasHeight / 2);
        ctx.restore();
        return;
      }
      updateHeader();
      // barrier lines (red dashed)
      if (document.getElementById('showBarriers').checked && Array.isArray(data.barrier_line)) {
        ctx.save(); ctx.setLineDash([6, 4]); ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(200,30,30,0.9)';
        for (const b of data.barrier_line) { const x1 = toCanvasX(b.x1), y1 = toCanvasY(b.y1), x2 = toCanvasX(b.x2), y2 = toCanvasY(b.y2); ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); }
        ctx.restore();
      }
      // obstacle boxes (filled translucent gray)
      if (document.getElementById('showObstacles').checked && Array.isArray(data.obstacle_box)) {
        ctx.save(); ctx.fillStyle = 'rgba(100,100,100,0.12)'; ctx.strokeStyle = 'rgba(80,80,80,0.9)'; ctx.lineWidth = 1.5;
        for (const box of data.obstacle_box) { const pts = ['a', 'b', 'c', 'd'].map(k => box[k]).filter(Boolean); if (!pts.length) continue; ctx.beginPath(); ctx.moveTo(toCanvasX(pts[0].x), toCanvasY(pts[0].y)); for (let i = 1; i < pts.length; i++) ctx.lineTo(toCanvasX(pts[i].x), toCanvasY(pts[i].y)); ctx.closePath(); ctx.fill(); ctx.stroke(); }
        ctx.restore();
      }
      // target exterior (green translucent polygon)
      if (document.getElementById('showTargets').checked && Array.isArray(data.target_exterior) && data.target_exterior.length) {
        const pts = data.target_exterior.map(p => ({ x: toCanvasX(p.x), y: toCanvasY(p.y) }));
        if (pts.length > 1) { ctx.save(); ctx.fillStyle = 'rgba(40,160,60,0.12)'; ctx.strokeStyle = 'rgba(40,160,60,0.9)'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y); for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore(); }
      }
      // draw center (if provided)
      if (data && data.center && typeof data.center.x === 'number' && typeof data.center.y === 'number') {
        const cx = toCanvasX(data.center.x), cy = toCanvasY(data.center.y);
        ctx.save();
        const R = 10; // bigger marker radius
        ctx.fillStyle = 'rgba(30,90,240,0.12)';
        ctx.strokeStyle = 'rgba(20,20,220,0.9)';
        ctx.lineWidth = 2;
        // filled disk + ring
        ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        // crosshair
        const arm = R + 4;
        ctx.beginPath(); ctx.moveTo(cx - arm, cy); ctx.lineTo(cx + arm, cy); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(cx, cy - arm); ctx.lineTo(cx, cy + arm); ctx.stroke();
        ctx.restore();
      }
      // part lines（两轮：先整体绘制并视情况变暗，再对活动对象（线/整件）加强绘制）
      if (document.getElementById('showParts').checked) {
        const activeItem = selectedFocus || hoveredFocus || null;
        const activeId = selectedPartId != null ? selectedPartId : (activeItem ? activeItem.part_id : (hoveredPartId ?? null));
        const drawLine = (p, item, strong = false) => {
          const s = item.lineSegment; const x1 = toCanvasX(s.x1), y1 = toCanvasY(s.y1), x2 = toCanvasX(s.x2), y2 = toCanvasY(s.y2);
          const col = colorForWeight(p.hue, item.weight, p.minW, p.maxW);
          const t = (item.weight - p.minW) / ((p.maxW - p.minW) || 1);
          ctx.strokeStyle = strong ? '#000' : col;
          const w = 1 + 4 * t;
          ctx.lineWidth = strong ? Math.max(2.5, w + 1) : w;
          ctx.lineCap = 'round';
          ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
          // end caps
          ctx.beginPath(); ctx.fillStyle = strong ? '#000' : col; ctx.arc(x1, y1, (ctx.lineWidth / 2), 0, Math.PI * 2); ctx.fill();
          ctx.beginPath(); ctx.arc(x2, y2, (ctx.lineWidth / 2), 0, Math.PI * 2); ctx.fill();
        };
        // 第一轮：全部正常色（若有活动对象/活动部件，则降低整体透明度；但跳过活动部件（仅在没有活动具体线时）或活动线本身，留给第二轮加强）
        const dimOthers = (activeItem != null) || (activeId != null);
        ctx.save(); if (dimOthers) ctx.globalAlpha = 0.35;
        for (const p of parts) {
          const lines = p.lines || [];
          const isActivePart = (activeItem == null) && (activeId != null) && (p.part_id === activeId);
          for (let i = 0; i < lines.length; i++) {
            const item = lines[i];
            const isActiveLine = activeItem && activeItem.type === 'line' && p.part_id === activeItem.part_id && i === activeItem.lineIdx;
            if (isActivePart || isActiveLine) continue; // 第二轮加强绘制
            drawLine(p, item, false);
          }
        }
        ctx.restore();
        // 第二轮：若有活动线，单独加强；否则若有活动部件，整个部件加强
        if (activeItem && activeItem.type === 'line') {
          const p = parts.find(pp => pp.part_id === activeItem.part_id);
          if (p && p.lines && p.lines[activeItem.lineIdx]) drawLine(p, p.lines[activeItem.lineIdx], true);
        } else if (activeId != null) {
          for (const p of parts) { if (p.part_id !== activeId) continue; for (const item of (p.lines || [])) drawLine(p, item, true); }
        }
      }
      // part points（与线相同策略：其他弱化，当前 part 加强）
      if (document.getElementById('showParts').checked) {
        const activeItem = selectedFocus || hoveredFocus || null;
        const activeId = selectedPartId != null ? selectedPartId : (activeItem ? activeItem.part_id : (hoveredPartId ?? null));
        const drawPoint = (p, pt, strong = false) => {
          const cx = toCanvasX(pt.coordinate.x), cy = toCanvasY(pt.coordinate.y);
          const col = colorForWeight(p.hue, pt.weight, p.minW, p.maxW);
          const r = (4 + ((pt.weight - p.minW) / ((p.maxW - p.minW) || 1)) * 4) * (strong ? 1.15 : 1);
          ctx.beginPath(); ctx.fillStyle = strong ? '#000' : col; ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.fill();
          ctx.beginPath(); ctx.strokeStyle = strong ? 'rgba(255,255,255,0.9)' : 'rgba(255,255,255,0.6)'; ctx.lineWidth = strong ? 1.5 : 1; ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.stroke();
        };
        const dimOthers = (activeItem != null) || (activeId != null);
        ctx.save(); if (dimOthers) ctx.globalAlpha = 0.35;
        for (const p of pointsParts) {
          const pts = p.points || [];
          const isActivePart = (activeItem == null) && (activeId != null) && (p.part_id === activeId);
          for (let i = 0; i < pts.length; i++) {
            const pt = pts[i];
            const isActivePoint = activeItem && activeItem.type === 'point' && p.part_id === activeItem.part_id && i === activeItem.pointIdx;
            if (isActivePart || isActivePoint) continue;
            drawPoint(p, pt, false);
          }
        }
        ctx.restore();
        if (activeItem && activeItem.type === 'point') {
          const p = pointsParts.find(pp => pp.part_id === activeItem.part_id);
          if (p && p.points && p.points[activeItem.pointIdx]) drawPoint(p, p.points[activeItem.pointIdx], true);
        } else if (activeId != null) {
          for (const p of pointsParts) { if (p.part_id !== activeId) continue; for (const pt of p.points || []) drawPoint(p, pt, true); }
        }
      }
      // solution lines layer
      if (document.getElementById('showSolution').checked && solutionLines.length) {
        const activeSol = (selectedFocus && selectedFocus.type === 'solution_line') ? selectedFocus : (hoveredFocus && hoveredFocus.type === 'solution_line' ? hoveredFocus : null);
        const activeIdx = activeSol ? activeSol.solutionIdx : null;
        const dimOthers = activeIdx != null;
        const partHueMap = new Map(partMeta.map(m => [m.part_id, m.hue]));
        const colorForSol = (sl) => `hsl(${partHueMap.get(sl.part_id) ?? 35} 85% 45%)`;
        const drawSol = (sl, strong = false) => {
          const sx = toCanvasX(sl.start.x), sy = toCanvasY(sl.start.y), ex = toCanvasX(sl.end.x), ey = toCanvasY(sl.end.y);
          const col = colorForSol(sl);
          ctx.save();
          ctx.lineCap = 'round'; ctx.lineJoin = 'round';
          ctx.strokeStyle = strong ? '#000' : col; ctx.lineWidth = strong ? 4 : 3;
          ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); ctx.stroke();
          // arrow head
          const dx = ex - sx, dy = ey - sy; const len = Math.hypot(dx, dy) || 1; const ux = dx / len, uy = dy / len; const ah = strong ? 9 : 7; const aw = strong ? 5 : 4; const ax = ex - ux * ah, ay = ey - uy * ah; /* smaller arrow */
          ctx.beginPath(); ctx.fillStyle = strong ? '#000' : col; ctx.moveTo(ex, ey); ctx.lineTo(ax + (-uy) * aw, ay + ux * aw); ctx.lineTo(ax + uy * aw, ay + (-ux) * aw); ctx.closePath(); ctx.fill();
          // label (place outside end point along extension)
          const label = `S${sl.__idx}`;
          const extend = 14 + (strong ? 4 : 0); // distance beyond endpoint
          const lx = ex + ux * extend; const ly = ey + uy * extend;
          ctx.font = '12px system-ui'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          const metrics = ctx.measureText(label); const bw = metrics.width + 6; const bh = 16;
          ctx.fillStyle = 'rgba(255,255,255,0.85)';
          if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(lx - bw / 2, ly - bh / 2, bw, bh, 4); ctx.fill(); }
          else { ctx.fillRect(lx - bw / 2, ly - bh / 2, bw, bh); }
          ctx.fillStyle = strong ? col : '#333'; ctx.fillText(label, lx, ly + 0.5);
          ctx.restore();
        };
        ctx.save(); if (dimOthers) ctx.globalAlpha = 0.35;
        for (const sl of solutionLines) { if (sl.__idx === activeIdx) continue; drawSol(sl, false); }
        ctx.restore();
        if (activeIdx != null) { const sl = solutionLines.find(s => s.__idx === activeIdx); if (sl) drawSol(sl, true); }
      }
      if (!suppressLegend && !isLegendMouseDown) drawLegend();
      updateDetailsPanel();
    }

    function drawLegend() {
      legendContent.innerHTML = '';
      // Summary counts
      const countBarriers = Array.isArray(data?.barrier_line) ? data.barrier_line.length : 0;
      const countBoxes = Array.isArray(data?.obstacle_box) ? data.obstacle_box.length : 0;
      const countTargetPoints = Array.isArray(data?.target_exterior) ? data.target_exterior.length : 0;
      const countTargetPolys = countTargetPoints > 0 ? 1 : 0; // 当前 schema 为单一多边形（用点数组表示）
      const countParts = Array.isArray(partMeta) ? partMeta.length : 0;
      const countSolution = Array.isArray(solutionLines) ? solutionLines.length : 0;

      const countsCard = document.createElement('div');
      countsCard.className = 'details-card';
      const schemaName = (typeof data?.schema_name === 'string') ? data.schema_name : null;
      const centerHtml = (data && data.center && typeof data.center.x === 'number' && typeof data.center.y === 'number')
        ? `\n<div>center: (${Number(data.center.x).toFixed(2)}, ${Number(data.center.y).toFixed(2)})</div>`
        : '';
      countsCard.innerHTML = [
        schemaName ? `<div class="title">${schemaName}</div>` : '',
        '<div class="title">统计</div>',
        `\n<div>target_exterior: ${countTargetPolys}${countTargetPoints ? `（points: ${countTargetPoints}）` : ''}</div>`,
        `\n<div>obstacle_box: ${countBoxes}</div>`,
        `\n<div>barrier_line: ${countBarriers}</div>`,
        `\n<div>solution: ${countSolution}</div>`,
        `\n<div>parts: ${countParts}</div>`,
        centerHtml
      ].join('');
      legendContent.appendChild(countsCard);
      // sections
      const mkRow = (title, html) => { const r = document.createElement('div'); r.className = 'part-row'; r.innerHTML = `<strong>${title}</strong>${html ? `<div style="margin-top:6px">${html}</div>` : ''}`; legendContent.appendChild(r); return r; };
      mkRow(`barrier_line (${countBarriers})`, '<span class="color-swatch" style="background:linear-gradient(90deg, rgba(200,30,30,0.9), rgba(200,30,30,0.9))"></span> dashed red lines');
      mkRow(`obstacle_box (${countBoxes})`, '<span class="color-swatch" style="background:rgba(100,100,100,0.12)"></span> filled box');
      mkRow(`target_exterior (${countTargetPolys}${countTargetPoints ? ` · points ${countTargetPoints}` : ''})`, '<span class="color-swatch" style="background:rgba(40,160,60,0.25)"></span> filled polygon');
      if (countSolution) {
        const solTitle = document.createElement('div'); solTitle.className = 'legend-section-title'; solTitle.textContent = `solution (${countSolution})`; legendContent.appendChild(solTitle);
        const partHueMap = new Map(partMeta.map(m => [m.part_id, m.hue]));
        solutionLines.forEach(sl => {
          const row = document.createElement('div');
          const active = (selectedFocus && selectedFocus.type === 'solution_line' && selectedFocus.solutionIdx === sl.__idx) || (!selectedFocus && hoveredFocus && hoveredFocus.type === 'solution_line' && hoveredFocus.solutionIdx === sl.__idx);
          row.className = 'part-row' + (active ? ' active' : '');
          row.id = `legend-solution-line-${sl.__idx}`;
          const hue = partHueMap.get(sl.part_id) ?? 35;
          row.innerHTML = `<span class="color-swatch" style="background:hsl(${hue} 85% 45%)"></span>S${sl.__idx} part:#${sl.part_id ?? 'NA'} (${sl.start.x.toFixed(1)},${sl.start.y.toFixed(1)})→(${sl.end.x.toFixed(1)},${sl.end.y.toFixed(1)})`;
          row.addEventListener('mouseenter', () => { hoveredFocus = { type: 'solution_line', solutionIdx: sl.__idx }; suppressLegend = true; render(); suppressLegend = false; });
          row.addEventListener('mouseleave', () => { if (hoveredFocus && hoveredFocus.type === 'solution_line' && hoveredFocus.solutionIdx === sl.__idx) hoveredFocus = null; suppressLegend = true; render(); suppressLegend = false; });
          row.addEventListener('click', (e) => { e.stopPropagation(); const next = { type: 'solution_line', solutionIdx: sl.__idx }; selectedFocus = (selectedFocus && selectedFocus.type === 'solution_line' && selectedFocus.solutionIdx === sl.__idx) ? null : next; selectedPartId = null; focusCanvasOn(next); ensureLegendVisible(next); render(); });
          legendContent.appendChild(row);
        });
      }

      // parts summary title
      const partsTitle = document.createElement('div'); partsTitle.className = 'legend-section-title'; partsTitle.textContent = `parts (${countParts})`; legendContent.appendChild(partsTitle);
      // parts entries（使用 partMeta，聚合 line/point）
      const activeId = selectedPartId != null ? selectedPartId : hoveredPartId;
      for (const m of partMeta) {
        const row = document.createElement('div');
        const rowActive = (selectedFocus && selectedFocus.part_id === m.part_id) || (selectedPartId != null && selectedPartId === m.part_id) || (!selectedFocus && activeId != null && m.part_id === activeId);
        row.className = 'part-row' + (rowActive ? ' active' : '');
        row.id = `legend-part-${safeId(m.part_id)}`;
        // header
        const header = document.createElement('div'); header.className = 'part-header';
        const left = document.createElement('div'); left.className = 'part-name'; left.textContent = m.part_name || '(未命名部件)';
        const right = document.createElement('div'); right.className = 'part-meta';
        const idChip = document.createElement('span'); idChip.className = 'chip'; idChip.textContent = m.part_id != null ? `id: ${m.part_id}` : 'no-id';
        const countChip = document.createElement('span'); countChip.className = 'chip'; countChip.textContent = `lines: ${m.lineCount} · points: ${m.pointCount}`;
        right.appendChild(idChip); right.appendChild(countChip);
        header.appendChild(left); header.appendChild(right); row.appendChild(header);
        // weight scale swatches
        const line = document.createElement('div'); line.className = 'row-line';
        const swMin = document.createElement('span'); swMin.className = 'swatch'; swMin.style.background = colorForWeight(m.hue, m.minW, m.minW, m.maxW);
        const swMax = document.createElement('span'); swMax.className = 'swatch'; swMax.style.background = colorForWeight(m.hue, m.maxW, m.minW, m.maxW);
        const wtxt = document.createElement('span'); wtxt.style.fontSize = '12px'; wtxt.textContent = `weight: ${m.minW} ⇢ ${m.maxW}`;
        line.appendChild(swMin); line.appendChild(swMax); line.appendChild(wtxt);
        row.appendChild(line);
        // 子列表：线
        const linePart = parts.find(p => p.part_id === m.part_id);
        // 如果该部件有线段，计算线段总长度并放到 header 右侧 chip
        if (linePart && Array.isArray(linePart.lines) && linePart.lines.length) {
          let totalLen = 0;
          for (const it of linePart.lines) {
            const s = it.lineSegment || {};
            const dx = (s.x2 ?? 0) - (s.x1 ?? 0);
            const dy = (s.y2 ?? 0) - (s.y1 ?? 0);
            totalLen += Math.hypot(dx, dy);
          }
          const lenChip = document.createElement('span');
          lenChip.className = 'chip';
          lenChip.title = '线段总长度';
          lenChip.textContent = `ΣL: ${totalLen.toFixed(3)}`;
          right.appendChild(lenChip);
        }
        if (linePart && Array.isArray(linePart.lines) && linePart.lines.length) {
          const sub = document.createElement('div'); sub.className = 'sublist';
          const title = document.createElement('div'); title.style.fontSize = '12px'; title.style.color = '#666'; title.textContent = `lines (${linePart.lines.length})`;
          sub.appendChild(title);
          // 排序：按权重从大到小，但保留原索引用于选择与渲染
          const sortedLines = linePart.lines.map((it, idx) => ({ it, idx })).sort((a, b) => (b.it.weight ?? 0) - (a.it.weight ?? 0));
          sortedLines.forEach(({ it, idx }) => {
            const el = document.createElement('div'); el.className = 'subitem';
            el.id = `legend-part-${safeId(m.part_id)}-line-${idx}`;
            const isActive = (selectedFocus && selectedFocus.type === 'line' && selectedFocus.part_id === m.part_id && selectedFocus.lineIdx === idx) || (!selectedFocus && hoveredFocus && hoveredFocus.type === 'line' && hoveredFocus.part_id === m.part_id && hoveredFocus.lineIdx === idx);
            if (isActive) el.classList.add('active');
            el.textContent = `#${idx} weight=${it.weight}  (${it.lineSegment.x1.toFixed(1)},${it.lineSegment.y1.toFixed(1)}) → (${it.lineSegment.x2.toFixed(1)},${it.lineSegment.y2.toFixed(1)})`;
            el.addEventListener('mouseenter', () => { hoveredPartId = m.part_id; hoveredFocus = { type: 'line', part_id: m.part_id, lineIdx: idx }; suppressLegend = true; render(); suppressLegend = false; });
            el.addEventListener('mouseleave', () => { hoveredFocus = null; hoveredPartId = null; suppressLegend = true; render(); suppressLegend = false; });
            el.addEventListener('click', (e) => { if (document.getElementById('dragOverlay')?.style.display === 'flex') return; e.stopPropagation(); selectedPartId = null; selectedFocus = (selectedFocus && selectedFocus.type === 'line' && selectedFocus.part_id === m.part_id && selectedFocus.lineIdx === idx) ? null : { type: 'line', part_id: m.part_id, lineIdx: idx }; focusCanvasOn({ type: 'line', part_id: m.part_id, lineIdx: idx }); ensureLegendVisible({ type: 'line', part_id: m.part_id, lineIdx: idx }); render(); });
            el.addEventListener('dblclick', (e) => { if (document.getElementById('dragOverlay')?.style.display === 'flex') return; e.stopPropagation(); selectedFocus = null; selectedPartId = (selectedPartId === m.part_id) ? null : m.part_id; focusCanvasOn({ type: 'part', part_id: m.part_id }); ensureLegendVisible({ type: 'part', part_id: m.part_id }); render(); });
            sub.appendChild(el);
          });
          row.appendChild(sub);
        }
        // 子列表：点
        const pointPart = pointsParts.find(p => p.part_id === m.part_id);
        if (pointPart && Array.isArray(pointPart.points) && pointPart.points.length) {
          const sub = document.createElement('div'); sub.className = 'sublist';
          const title = document.createElement('div'); title.style.fontSize = '12px'; title.style.color = '#666'; title.textContent = `points (${pointPart.points.length})`;
          sub.appendChild(title);
          // 排序：按权重从大到小，保留原索引用于选择与渲染
          const sortedPoints = pointPart.points.map((pt, idx) => ({ pt, idx })).sort((a, b) => (b.pt.weight ?? 0) - (a.pt.weight ?? 0));
          sortedPoints.forEach(({ pt, idx }) => {
            const el = document.createElement('div'); el.className = 'subitem';
            el.id = `legend-part-${safeId(m.part_id)}-point-${idx}`;
            const isActive = (selectedFocus && selectedFocus.type === 'point' && selectedFocus.part_id === m.part_id && selectedFocus.pointIdx === idx) || (!selectedFocus && hoveredFocus && hoveredFocus.type === 'point' && hoveredFocus.part_id === m.part_id && hoveredFocus.pointIdx === idx);
            if (isActive) el.classList.add('active');
            el.textContent = `#${idx} weight=${pt.weight}  (${pt.coordinate.x.toFixed(1)},${pt.coordinate.y.toFixed(1)})`;
            el.addEventListener('mouseenter', () => { hoveredPartId = m.part_id; hoveredFocus = { type: 'point', part_id: m.part_id, pointIdx: idx }; suppressLegend = true; render(); suppressLegend = false; });
            el.addEventListener('mouseleave', () => { hoveredFocus = null; hoveredPartId = null; suppressLegend = true; render(); suppressLegend = false; });
            el.addEventListener('click', (e) => { if (document.getElementById('dragOverlay')?.style.display === 'flex') return; e.stopPropagation(); selectedPartId = null; selectedFocus = (selectedFocus && selectedFocus.type === 'point' && selectedFocus.part_id === m.part_id && selectedFocus.pointIdx === idx) ? null : { type: 'point', part_id: m.part_id, pointIdx: idx }; focusCanvasOn({ type: 'point', part_id: m.part_id, pointIdx: idx }); ensureLegendVisible({ type: 'point', part_id: m.part_id, pointIdx: idx }); render(); });
            el.addEventListener('dblclick', (e) => { if (document.getElementById('dragOverlay')?.style.display === 'flex') return; e.stopPropagation(); selectedFocus = null; selectedPartId = (selectedPartId === m.part_id) ? null : m.part_id; focusCanvasOn({ type: 'part', part_id: m.part_id }); ensureLegendVisible({ type: 'part', part_id: m.part_id }); render(); });
            sub.appendChild(el);
          });
          row.appendChild(sub);
        }
        // 交互：Legend 上 hover/点击（整件）
        row.addEventListener('mouseenter', () => { hoveredPartId = m.part_id ?? null; if (!hoveredFocus) hoveredFocus = { type: 'part', part_id: m.part_id }; suppressLegend = true; render(); suppressLegend = false; });
        row.addEventListener('mouseleave', () => { hoveredPartId = null; if (hoveredFocus && hoveredFocus.type === 'part' && hoveredFocus.part_id === m.part_id) hoveredFocus = null; suppressLegend = true; render(); suppressLegend = false; });
        row.addEventListener('click', (e) => {
          if (document.getElementById('dragOverlay')?.style.display === 'flex') return;
          // 点击整件：清理具体选中，切换整件选中，并让画布聚焦
          selectedFocus = null;
          selectedPartId = (selectedPartId === m.part_id) ? null : (m.part_id ?? null);
          focusCanvasOn({ type: 'part', part_id: m.part_id });
          ensureLegendVisible({ type: 'part', part_id: m.part_id });
          render();
        });
        row.addEventListener('dblclick', (e) => { if (document.getElementById('dragOverlay')?.style.display === 'flex') return; e.stopPropagation(); selectedFocus = null; selectedPartId = (selectedPartId === m.part_id) ? null : (m.part_id ?? null); focusCanvasOn({ type: 'part', part_id: m.part_id }); render(); });
        legendContent.appendChild(row);
      }
    }

    function updateDetailsPanel() {
      const el = document.getElementById('details');
      if (!el) return;
      const subject = selectedFocus || hoveredFocus || (selectedPartId != null ? { type: 'part', part_id: selectedPartId } : (hoveredPartId != null ? { type: 'part', part_id: hoveredPartId } : null));
      if (!data || !subject) { el.innerHTML = ''; return; }
      const meta = partMeta.find(m => m.part_id === subject.part_id);
      let html = '';
      if (subject.type === 'part') {
        html += `<div class="title">部件：${meta?.part_name ?? ''} <span class="mono">#${subject.part_id ?? 'NA'}</span></div>`;
        if (meta) {
          html += `<div>lines: ${meta.lineCount} · points: ${meta.pointCount}</div>`;
          html += `<div>weight: ${meta.minW} ⇢ ${meta.maxW}</div>`;
        }
      } else if (subject.type === 'line') {
        const p = parts.find(pp => pp.part_id === subject.part_id);
        const it = p && p.lines ? p.lines[subject.lineIdx] : null;
        html += `<div class="title">线段 <span class="mono">#${subject.lineIdx}</span> @ 部件 <span class="mono">#${subject.part_id}</span></div>`;
        if (it) {
          const s = it.lineSegment;
          html += `<div>weight: ${it.weight}</div>`;
          html += `<div>(${s.x1.toFixed(2)}, ${s.y1.toFixed(2)}) → (${s.x2.toFixed(2)}, ${s.y2.toFixed(2)})</div>`;
          // 几何量：长度与归一化方向角（度）
          const dx = (s.x2 ?? 0) - (s.x1 ?? 0);
          const dy = (s.y2 ?? 0) - (s.y1 ?? 0);
          const len = Math.hypot(dx, dy);
          if (len > 0) {
            const angleRad = Math.atan2(dy, dx);
            const angleDeg = (angleRad * 180 / Math.PI + 360) % 360;
            html += `<div>长度: ${len.toFixed(3)}</div>`;
            html += `<div>角度(归一化向量): ${angleDeg.toFixed(1)}&deg;</div>`;
          } else {
            html += `<div>长度: 0</div>`;
            html += `<div>角度(归一化向量): —</div>`;
          }
        }
      } else if (subject.type === 'point') {
        const p = pointsParts.find(pp => pp.part_id === subject.part_id);
        const pt = p && p.points ? p.points[subject.pointIdx] : null;
        html += `<div class="title">点 <span class="mono">#${subject.pointIdx}</span> @ 部件 <span class="mono">#${subject.part_id}</span></div>`;
        if (pt) {
          html += `<div>weight: ${pt.weight}</div>`;
          html += `<div>(${pt.coordinate.x.toFixed(2)}, ${pt.coordinate.y.toFixed(2)})</div>`;
        }
      }
      el.innerHTML = html;
    }

    // ------------------------------
    // Hit testing：统一返回最接近的元素（line/point/box/barrier/target）
    // 所有检测在 canvas 像素坐标空间中进行
    // ------------------------------
    function distPointToSegment(px, py, x1, y1, x2, y2) { const dx = x2 - x1, dy = y2 - y1; const l2 = dx * dx + dy * dy || 1e-9; let t = ((px - x1) * dx + (py - y1) * dy) / l2; t = Math.max(0, Math.min(1, t)); const projx = x1 + t * dx, projy = y1 + t * dy; return { dist: Math.hypot(px - projx, py - projy), projx, projy, t }; }

    function findHitAt(pxCanvas, pyCanvas, threshold = 6) {
      let best = null;
      // Respect layer toggles
      const showObstacles = !!document.getElementById('showObstacles')?.checked;
      const showBarriers = !!document.getElementById('showBarriers')?.checked;
      const showTargets = !!document.getElementById('showTargets')?.checked;
      const showParts = !!document.getElementById('showParts')?.checked;
      const showSolution = !!document.getElementById('showSolution')?.checked;
      if (showSolution) {
        for (const sl of solutionLines) {
          if (!sl.start || !sl.end) continue;
          const sx = toCanvasX(sl.start.x), sy = toCanvasY(sl.start.y), ex = toCanvasX(sl.end.x), ey = toCanvasY(sl.end.y);
          const d = distPointToSegment(pxCanvas, pyCanvas, sx, sy, ex, ey);
          if (d.dist <= threshold && (!best || d.dist < best.dist)) best = { type: 'solution_line', line: sl, solutionIdx: sl.__idx, x1: sx, y1: sy, x2: ex, y2: ey, dist: d.dist };
        }
      }
      // part lines
      if (showParts) { for (const p of parts) { const arr = p.lines || []; for (let i = 0; i < arr.length; i++) { const item = arr[i]; const s = item.lineSegment; const x1 = toCanvasX(s.x1), y1 = toCanvasY(s.y1), x2 = toCanvasX(s.x2), y2 = toCanvasY(s.y2); const d = distPointToSegment(pxCanvas, pyCanvas, x1, y1, x2, y2); if (d.dist <= threshold && (!best || d.dist < best.dist)) best = { type: 'part_line', part: p, item, lineIdx: i, x1, y1, x2, y2, dist: d.dist, projx: d.projx, projy: d.projy }; } } }
      // part points
      if (showParts) { for (const p of pointsParts) { const arr = p.points || []; for (let i = 0; i < arr.length; i++) { const pt = arr[i]; const cx = toCanvasX(pt.coordinate.x), cy = toCanvasY(pt.coordinate.y); const d = Math.hypot(pxCanvas - cx, pyCanvas - cy); const r = 4 + ((pt.weight - p.minW) / ((p.maxW - p.minW) || 1)) * 4; if (d <= Math.max(threshold, r + 3) && (!best || d < best.dist)) best = { type: 'part_point', part: p, pt, pointIdx: i, cx, cy, r, dist: d }; } } }
      // barrier lines
      if (showBarriers && data && Array.isArray(data.barrier_line)) {
        for (const b of data.barrier_line) { const x1 = toCanvasX(b.x1), y1 = toCanvasY(b.y1), x2 = toCanvasX(b.x2), y2 = toCanvasY(b.y2); const d = distPointToSegment(pxCanvas, pyCanvas, x1, y1, x2, y2); if (d.dist <= threshold && (!best || d.dist < best.dist)) best = { type: 'barrier', item: b, x1, y1, x2, y2, dist: d.dist }; }
      }
      // obstacle boxes: check edge distance and point-in-polygon
      if (showObstacles && data && Array.isArray(data.obstacle_box)) {
        for (const box of data.obstacle_box) {
          const pts = ['a', 'b', 'c', 'd'].map(k => box[k]).filter(Boolean); if (!pts.length) continue; // edges
          // edges
          for (let i = 0; i < pts.length; i++) { const p1 = pts[i]; const p2 = pts[(i + 1) % pts.length]; const x1 = toCanvasX(p1.x), y1 = toCanvasY(p1.y), x2 = toCanvasX(p2.x), y2 = toCanvasY(p2.y); const d = distPointToSegment(pxCanvas, pyCanvas, x1, y1, x2, y2); if (d.dist <= threshold && (!best || d.dist < best.dist)) best = { type: 'obstacle_edge', item: box, edge: [p1, p2], x1, y1, x2, y2, dist: d.dist }; }
          // inside polygon (ray casting)
          let inside = false; for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) { const xi = toCanvasX(pts[i].x), yi = toCanvasY(pts[i].y); const xj = toCanvasX(pts[j].x), yj = toCanvasY(pts[j].y); const intersect = ((yi > pyCanvas) != (yj > pyCanvas)) && (pxCanvas < (xj - xi) * (pyCanvas - yi) / (yj - yi + 1e-9) + xi); if (intersect) inside = !inside; }
          if (inside && (!best || 0 < best.dist)) best = { type: 'obstacle_inside', item: box, dist: 0 };
        }
      }
      // target exterior edges
      if (showTargets && data && Array.isArray(data.target_exterior) && data.target_exterior.length > 1) { const pts = data.target_exterior; for (let i = 0; i < pts.length - 1; i++) { const p1 = pts[i], p2 = pts[i + 1]; const x1 = toCanvasX(p1.x), y1 = toCanvasY(p1.y), x2 = toCanvasX(p2.x), y2 = toCanvasY(p2.y); const d = distPointToSegment(pxCanvas, pyCanvas, x1, y1, x2, y2); if (d.dist <= threshold && (!best || d.dist < best.dist)) best = { type: 'target_edge', item: { p1, p2 }, x1, y1, x2, y2, dist: d.dist }; } }

      // center point (if provided)
      if (data && data.center && typeof data.center.x === 'number' && typeof data.center.y === 'number') {
        const cx = toCanvasX(data.center.x), cy = toCanvasY(data.center.y);
        const d = Math.hypot(pxCanvas - cx, pyCanvas - cy);
        const thr = Math.max(threshold, 12);
        if (d <= thr && (!best || d < best.dist)) best = { type: 'center', cx, cy, dist: d };
      }

      return best;
    }

    // ------------------------------
    // Mouse handling（把 client -> canvas 像素做转换）
    // ------------------------------
    canvas.addEventListener('mousemove', ev => {
      if (isPanning) { tooltip.style.display = 'none'; return; }
      if (!data) { tooltip.style.display = 'none'; return; }
      const rect = canvas.getBoundingClientRect();
      const wrapRect = canvasWrap.getBoundingClientRect();
      const mx = ev.clientX - rect.left; // CSS px relative to canvas (already includes translate)
      const my = ev.clientY - rect.top;
      // map CSS px to canvas px
      const mxCanvas = mx * (baseCanvasWidth / rect.width);
      const myCanvas = my * (baseCanvasHeight / rect.height);
      const hit = findHitAt(mxCanvas, myCanvas, 8);
      if (hit) {
        // tooltip in CSS px
        tooltip.style.display = 'block';
        // position near the cursor (bottom-right), independent of canvas translate pan
        const left = canvasWrap.scrollLeft + (ev.clientX - wrapRect.left) + 12;
        const top = canvasWrap.scrollTop + (ev.clientY - wrapRect.top) + 12;
        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        // compose info
        let html = '';
        if (hit.type === 'part_line') {
          html += `<div style="font-weight:600">part line — ${hit.part.part_name} <span style="font-weight:400;color:#aaa">(#${hit.part.part_id ?? 'NA'})</span></div>`;
          html += `<div>weight: ${hit.item.weight}</div>`;
          const s = hit.item.lineSegment; html += `<div>(${s.x1.toFixed(2)}, ${s.y1.toFixed(2)}) → (${s.x2.toFixed(2)}, ${s.y2.toFixed(2)})</div>`;
          // 长度与归一化方向角（度）
          {
            const dx = (s.x2 ?? 0) - (s.x1 ?? 0);
            const dy = (s.y2 ?? 0) - (s.y1 ?? 0);
            const len = Math.hypot(dx, dy);
            if (len > 0) {
              const angleDeg = ((Math.atan2(dy, dx) * 180 / Math.PI) + 360) % 360;
              html += `<div>长度: ${len.toFixed(3)} · 角度: ${angleDeg.toFixed(1)}&deg;</div>`;
            } else {
              html += `<div>长度: 0 · 角度: —</div>`;
            }
          }
          // 聚合统计
          const meta = partMeta.find(m => m.part_id === hit.part.part_id);
          if (meta) html += `<div style="margin-top:4px;color:#ddd">lines: ${meta.lineCount} · points: ${meta.pointCount} · weight ${meta.minW}–${meta.maxW}</div>`;
          hoveredPartId = hit.part.part_id ?? null; hoveredFocus = { type: 'line', part_id: hit.part.part_id, lineIdx: hit.lineIdx };
        }
        else if (hit.type === 'part_point') {
          html += `<div style="font-weight:600">part point — ${hit.part.part_name} <span style="font-weight:400;color:#aaa">(#${hit.part.part_id ?? 'NA'})</span></div>`;
          html += `<div>weight: ${hit.pt.weight}</div>`;
          html += `<div>(${hit.pt.coordinate.x.toFixed(2)}, ${hit.pt.coordinate.y.toFixed(2)})</div>`;
          const meta = partMeta.find(m => m.part_id === hit.part.part_id);
          if (meta) html += `<div style="margin-top:4px;color:#ddd">lines: ${meta.lineCount} · points: ${meta.pointCount} · weight ${meta.minW}–${meta.maxW}</div>`;
          hoveredPartId = hit.part.part_id ?? null; hoveredFocus = { type: 'point', part_id: hit.part.part_id, pointIdx: hit.pointIdx };
        }
        else if (hit.type === 'solution_line') { const sl = hit.line; html += `<div style=\"font-weight:600\">solution 线段 <span style=\"font-weight:400;color:#aaa\">(S${sl.__idx})</span></div>`; html += `<div>part_id: ${sl.part_id ?? 'NA'}</div>`; html += `<div>(${sl.start.x.toFixed(2)}, ${sl.start.y.toFixed(2)}) → (${sl.end.x.toFixed(2)}, ${sl.end.y.toFixed(2)})</div>`; const dx = sl.end.x - sl.start.x, dy = sl.end.y - sl.start.y; const len = Math.hypot(dx, dy); const angleDeg = len > 0 ? ((Math.atan2(dy, dx) * 180 / Math.PI) + 360) % 360 : null; html += `<div>长度: ${len.toFixed(3)} · 角度: ${angleDeg != null ? angleDeg.toFixed(1) + '&deg;' : '—'}</div>`; hoveredFocus = { type: 'solution_line', solutionIdx: sl.__idx }; }
        else if (hit.type === 'barrier') { html += `<div style="font-weight:600">barrier_line</div>`; const b = hit.item; html += `<div>(${b.x1.toFixed(2)}, ${b.y1.toFixed(2)}) → (${b.x2.toFixed(2)}, ${b.y2.toFixed(2)})</div>`; }
        else if (hit.type === 'obstacle_edge' || hit.type === 'obstacle_inside') { html += `<div style="font-weight:600">obstacle_box</div>`; html += `<div>box corners: ${Object.keys(hit.item).map(k => { const p = hit.item[k]; return `(${p.x.toFixed(2)},${p.y.toFixed(2)})`; }).join(', ')}</div>`; }
        else if (hit.type === 'target_edge') { html += `<div style="font-weight:600">target_exterior</div>`; html += `<div>edge</div>`; }
        else if (hit.type === 'center') { html += `<div style="font-weight:600">中心点 (center)</div>`; if (data && data.center) { html += `<div>(${Number(data.center.x).toFixed(2)}, ${Number(data.center.y).toFixed(2)})</div>`; } }
        tooltip.innerHTML = html;
        // highlight the hit element after full render
        render(); // render 内根据 hoveredPartId 增强高亮
        ctx.save();
        ctx.strokeStyle = 'rgba(0,0,0,0.8)';
        ctx.lineWidth = 2.5;
        if (hit.type === 'part_line' || hit.type === 'barrier' || hit.type === 'target_edge' || hit.type === 'obstacle_edge' || hit.type === 'solution_line') {
          ctx.beginPath(); ctx.moveTo(hit.x1, hit.y1); ctx.lineTo(hit.x2, hit.y2); ctx.stroke();
        } else if (hit.type === 'part_point') {
          ctx.beginPath(); ctx.arc(hit.cx, hit.cy, hit.r + 2, 0, Math.PI * 2); ctx.stroke();
        } else if (hit.type === 'obstacle_inside') {
          // draw thicker outline
          const pts = ['a', 'b', 'c', 'd'].map(k => hit.item[k]).filter(Boolean);
          if (pts.length) { ctx.beginPath(); ctx.moveTo(toCanvasX(pts[0].x), toCanvasY(pts[0].y)); for (let i = 1; i < pts.length; i++) ctx.lineTo(toCanvasX(pts[i].x), toCanvasY(pts[i].y)); ctx.closePath(); ctx.stroke(); }
        } else if (hit.type === 'center') {
          const R = 12;
          ctx.beginPath(); ctx.arc(hit.cx, hit.cy, R, 0, Math.PI * 2); ctx.stroke();
        }
        ctx.restore();
      } else {
        tooltip.style.display = 'none';
        if (hoveredPartId != null || hoveredFocus != null) { hoveredPartId = null; hoveredFocus = null; render(); }
        else { render(); }
      }
    });

    canvas.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; if (hoveredPartId != null) { hoveredPartId = null; } render(); });

    // ------------------------------
    // Middle mouse drag to pan (scroll the wrapper)
    // ------------------------------
    canvasWrap.addEventListener('mousedown', ev => {
      if (ev.button !== 1) return; // middle button only
      isPanning = true;
      panStartX = ev.clientX;
      panStartY = ev.clientY;
      startPanX = panX;
      startPanY = panY;
      canvasWrap.style.cursor = 'grabbing';
      tooltip.style.display = 'none';
      ev.preventDefault();
      ev.stopPropagation();
    });

    window.addEventListener('mousemove', ev => {
      if (!isPanning) return;
      const dx = ev.clientX - panStartX;
      const dy = ev.clientY - panStartY;
      panX = startPanX + dx;
      panY = startPanY + dy;
      applyPanTransform();
    });

    window.addEventListener('mouseup', () => {
      if (!isPanning) return;
      isPanning = false;
      canvasWrap.style.cursor = '';
    });

    // Prevent default middle-click auto-scroll/auxclick behavior on the wrapper
    canvasWrap.addEventListener('auxclick', ev => {
      if (ev.button === 1) {
        ev.preventDefault();
      }
    });

    // Zoom by resizing CSS width/height to avoid overlapping adjacent elements
    // initialize CSS size — fit wrapper uniformly
    requestAnimationFrame(() => {
      computeBaseCssScale();
      setCssSize(baseCssScale * currentScale);
      syncBackingStoreToCss();
      applyPanTransform();
    });
    function applyPanTransform() {
      // We only ever translate; zoom is handled by width/height.
      // Preserve any existing transform none -> translate.
      const tx = Math.round(panX);
      const ty = Math.round(panY);
      if (tx === 0 && ty === 0) {
        canvas.style.transform = 'translate(0px, 0px)';
      } else {
        canvas.style.transform = `translate(${tx}px, ${ty}px)`;
      }
    }
    canvas.addEventListener('wheel', ev => {
      ev.preventDefault();
      const wrapRect = canvasWrap.getBoundingClientRect();
      const rect = canvas.getBoundingClientRect();
      const oldCssScale = rect.width / baseCanvasWidth;
      const mxWrap = ev.clientX - wrapRect.left;
      const myWrap = ev.clientY - wrapRect.top;
      const xCanvas = (ev.clientX - rect.left) / oldCssScale;
      const yCanvas = (ev.clientY - rect.top) / oldCssScale;

      const delta = -ev.deltaY;
      const factor = delta > 0 ? 1.1 : 0.9;
      currentScale = Math.min(8, Math.max(0.2, currentScale * factor));
      const newCssScale = baseCssScale * currentScale;
      setCssSize(newCssScale);

      const newCssW = baseCanvasWidth * newCssScale;
      const newCssH = baseCanvasHeight * newCssScale;

      // 计算 translate 以保证锚点稳定，同时更新滚动条边界
      const needScrollX = newCssW > canvasWrap.clientWidth;
      const needScrollY = newCssH > canvasWrap.clientHeight;

      if (needScrollX) {
        const desired = xCanvas * newCssScale - mxWrap;
        const maxScroll = Math.max(0, newCssW - canvasWrap.clientWidth);
        canvasWrap.scrollLeft = Math.max(0, Math.min(desired, maxScroll));
        // 仍允许 translate 存在，用于中键平移
        panX = Math.round(mxWrap - xCanvas * newCssScale + canvasWrap.scrollLeft);
      } else {
        canvasWrap.scrollLeft = 0;
        panX = Math.round(mxWrap - xCanvas * newCssScale);
      }
      if (needScrollY) {
        const desired = yCanvas * newCssScale - myWrap;
        const maxScroll = Math.max(0, newCssH - canvasWrap.clientHeight);
        canvasWrap.scrollTop = Math.max(0, Math.min(desired, maxScroll));
        panY = Math.round(myWrap - yCanvas * newCssScale + canvasWrap.scrollTop);
      } else {
        canvasWrap.scrollTop = 0;
        panY = Math.round(myWrap - yCanvas * newCssScale);
      }

      applyPanTransform();
    });

    // 点击选择/取消选择零件/子项（单击选线/点，双击选整件）
    canvas.addEventListener('click', ev => {
      const rect = canvas.getBoundingClientRect();
      const mx = ev.clientX - rect.left;
      const my = ev.clientY - rect.top;
      const mxCanvas = mx * (baseCanvasWidth / rect.width);
      const myCanvas = my * (baseCanvasHeight / rect.height);
      const hit = findHitAt(mxCanvas, myCanvas, 8);

      // Shift+单击：立即选整件
      if (ev.shiftKey && hit && (hit.type === 'part_line' || hit.type === 'part_point')) {
        const pid = hit.part.part_id ?? null;
        selectedPartId = (selectedPartId === pid) ? null : pid;
        selectedFocus = null;
        ensureLegendVisible({ type: 'part', part_id: pid });
        render();
        return;
      }

      // 常规单击：延迟执行，若紧随其后出现双击则取消
      if (clickTimer) clearTimeout(clickTimer);
      clickTimer = setTimeout(() => {
        if (hit && hit.type === 'part_line') {
          const pid = hit.part.part_id ?? null;
          const next = { type: 'line', part_id: pid, lineIdx: hit.lineIdx };
          selectedFocus = (selectedFocus && selectedFocus.type === 'line' && selectedFocus.part_id === pid && selectedFocus.lineIdx === hit.lineIdx) ? null : next;
          selectedPartId = null;
          ensureLegendVisible(next);
        } else if (hit && hit.type === 'part_point') {
          const pid = hit.part.part_id ?? null;
          const next = { type: 'point', part_id: pid, pointIdx: hit.pointIdx };
          selectedFocus = (selectedFocus && selectedFocus.type === 'point' && selectedFocus.part_id === pid && selectedFocus.pointIdx === hit.pointIdx) ? null : next;
          selectedPartId = null;
          ensureLegendVisible(next);
        } else if (hit && hit.type === 'solution_line') {
          const next = { type: 'solution_line', solutionIdx: hit.solutionIdx };
          selectedFocus = (selectedFocus && selectedFocus.type === 'solution_line' && selectedFocus.solutionIdx === hit.solutionIdx) ? null : next;
          selectedPartId = null;
          ensureLegendVisible(next);
        } else {
          selectedFocus = null; selectedPartId = null;
        }
        render();
        clickTimer = null;
      }, CLICK_DELAY);
    });

    // 双击：选择整件（再双击同件可取消）
    canvas.addEventListener('dblclick', ev => {
      ev.preventDefault();
      if (clickTimer) { clearTimeout(clickTimer); clickTimer = null; }
      const rect = canvas.getBoundingClientRect();
      const mx = ev.clientX - rect.left;
      const my = ev.clientY - rect.top;
      const mxCanvas = mx * (baseCanvasWidth / rect.width);
      const myCanvas = my * (baseCanvasHeight / rect.height);
      const hit = findHitAt(mxCanvas, myCanvas, 8);
      if (hit) {
        if (hit.type === 'part_line' || hit.type === 'part_point') {
          const pid = hit.part.part_id ?? null;
          selectedPartId = (selectedPartId === pid) ? null : pid;
          selectedFocus = null;
          ensureLegendVisible({ type: 'part', part_id: pid });
        } else if (hit.type === 'solution_line') {
          // emulate double-click part: select part_id if available; otherwise just focus that solution line
          const sl = hit.line;
          if (sl && sl.part_id != null) {
            const pid = sl.part_id;
            selectedPartId = (selectedPartId === pid) ? null : pid;
            selectedFocus = null;
            ensureLegendVisible({ type: 'part', part_id: pid });
          } else {
            // fallback: treat as selecting the solution line itself
            selectedPartId = null;
            selectedFocus = { type: 'solution_line', solutionIdx: hit.solutionIdx };
            ensureLegendVisible({ type: 'solution_line', solutionIdx: hit.solutionIdx });
          }
        } else {
          selectedPartId = null; selectedFocus = null;
        }
      } else { selectedPartId = null; selectedFocus = null; }
      render();
    });

    // 点击 canvasWrap 的空白区域（不在 canvas 上）也取消选择/悬浮
    canvasWrap.addEventListener('click', (ev) => {
      // 仅当点击目标不是 canvas（即 wrapper 空白区域）时处理
      if (ev.target === canvas) return;
      // 避免正在拖拽/中键平移时误触
      if (isPanning) return;
      tooltip.style.display = 'none';
      hoveredFocus = null;
      hoveredPartId = null;
      selectedFocus = null;
      selectedPartId = null;
      render();
    });

    // 响应容器尺寸变化，保持不拉伸
    window.addEventListener('resize', () => {
      const prevCenterX = canvasWrap.scrollLeft + canvasWrap.clientWidth / 2;
      const prevCenterY = canvasWrap.scrollTop + canvasWrap.clientHeight / 2;
      computeBaseCssScale();
      setCssSize(baseCssScale * currentScale);
      syncBackingStoreToCss();
      applyPanTransform();
      // 尽量保持视野中心不变
      canvasWrap.scrollLeft = Math.max(0, prevCenterX - canvasWrap.clientWidth / 2);
      canvasWrap.scrollTop = Math.max(0, prevCenterY - canvasWrap.clientHeight / 2);
    });

    // layer toggles
    document.getElementById('showObstacles').addEventListener('change', render);
    document.getElementById('showBarriers').addEventListener('change', render);
    document.getElementById('showTargets').addEventListener('change', render);
    document.getElementById('showParts').addEventListener('change', render);
    document.getElementById('showSolution').addEventListener('change', render);

    // 首次渲染（无数据占位，需用户选择文件）
    render();

    // ------------- 剪贴板粘贴 JSON 支持 -------------
    function showTransientMsg(msg) {
      let box = document.getElementById('pasteHint');
      if (!box) {
        box = document.createElement('div');
        box.id = 'pasteHint';
        box.style.cssText = 'position:fixed;top:10px;right:10px;background:rgba(0,0,0,0.72);color:#fff;padding:6px 10px;font-size:12px;border-radius:4px;z-index:9999;pointer-events:none;max-width:260px;line-height:1.4;';
        document.body.appendChild(box);
      }
      box.textContent = msg;
      box.style.opacity = '1';
      clearTimeout(box.__timer);
      box.__timer = setTimeout(() => { box.style.transition = 'opacity .4s'; box.style.opacity = '0'; }, 1800);
    }
    // 仅当鼠标当前位于画布区域上方时才响应粘贴（限制作用域）
    let _isMouseOnCanvasWrap = false;
    const _canvasWrapForPaste = document.getElementById('canvasWrap');
    if (_canvasWrapForPaste) {
      _canvasWrapForPaste.addEventListener('mouseenter', () => { _isMouseOnCanvasWrap = true; });
      _canvasWrapForPaste.addEventListener('mouseleave', () => { _isMouseOnCanvasWrap = false; });
    }
    window.addEventListener('paste', (e) => {
      if (!_isMouseOnCanvasWrap) return; // 不在 canvas 区域: 直接忽略
      const target = e.target;
      if (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable)) return;
      // 先尝试是否为复制的文件 (资源管理器里 Ctrl+C 然后在此页面 Ctrl+V)
      const items = e.clipboardData?.items || [];
      const fileItems = [];
      for (const it of items) { if (it.kind === 'file') { const f = it.getAsFile(); if (f && /\.json$/i.test(f.name)) fileItems.push(f); } }
      if (fileItems.length) {
        e.preventDefault();
        let i = 0; function loadNext() { if (i >= fileItems.length) return; const f = fileItems[i++]; const r = new FileReader(); r.onload = () => { try { const json = JSON.parse(String(r.result)); if (window.__vis && window.__vis.openNewTab) { window.__vis.openNewTab(json, f.name); } else { setupFromData(json); } if (i === 1) showTransientMsg('已粘贴 ' + fileItems.length + ' 个 JSON 文件'); } catch (err) { alert('粘贴文件解析失败: ' + f.name + ' => ' + err.message); } finally { loadNext(); } }; r.onerror = () => { alert('粘贴文件读取失败: ' + f.name); loadNext(); }; r.readAsText(f, 'utf-8'); }
        loadNext();
      }
    });

    // ------------- 分隔条（调整 legend 宽度）-------------
    (function initSplitter() {
      const splitter = document.getElementById('splitter');
      if (!splitter) return;
      const legend = document.getElementById('legend');
      let dragging = false; let startX = 0; let startW = 0;
      const saved = localStorage.getItem('vis_legend_width');
      if (saved) {
        const w = parseInt(saved, 10); if (w > 160 && w < window.innerWidth - 200) { legend.style.width = w + 'px'; legend.style.flex = '0 0 ' + w + 'px'; }
      }
      splitter.addEventListener('mousedown', (e) => { dragging = true; startX = e.clientX; startW = legend.getBoundingClientRect().width; splitter.classList.add('dragging'); document.body.style.userSelect = 'none'; });
      // 根据反馈：向左拖动增大 legend（与常规逻辑相反）
      window.addEventListener('mousemove', (e) => { if (!dragging) return; const dx = e.clientX - startX; let newW = startW - dx; newW = Math.max(180, Math.min(newW, window.innerWidth - 260)); legend.style.width = newW + 'px'; legend.style.flex = '0 0 ' + newW + 'px'; });
      window.addEventListener('mouseup', () => { if (!dragging) return; dragging = false; splitter.classList.remove('dragging'); document.body.style.userSelect = ''; localStorage.setItem('vis_legend_width', parseInt(legend.style.width, 10)); });
    })();

    // Expose helper on window for debugging / programmatic load
    window.__vis = { toCanvasX, toCanvasY, setData: setupFromData, get data() { return data; } };
    // 监听 legend mousedown/up，避免中途重建 DOM 造成 click/dblclick 丢失
    if (legendRoot) {
      legendRoot.addEventListener('mousedown', () => { isLegendMouseDown = true; });
      window.addEventListener('mouseup', () => { if (isLegendMouseDown) { isLegendMouseDown = false; /* 让后续的 click 先触发，点击处理里会主动 render */ } });
    }

    // ================== 多标签页支持 ==================
    (function multiTab() {
      const tabBar = document.getElementById('tabBar');
      const addTabBtn = document.getElementById('addTabBtn');
      if (!tabBar || !addTabBtn) return; // 安全退化
      let tabs = [];
      let activeTabIndex = -1;
      let tabIdSeq = 1; // 唯一 id
      // ---- 持久化相关 ----
      const STORAGE_KEY = 'vis_tab_set_v1';
      function serializeTabs() {
        return JSON.stringify({
          ver: 1,
          active: activeTabIndex,
          tabs: tabs.map(t => ({
            id: t.__id,
            name: t.name,
            data: t.data, // 原始 json
            // 视图状态
            minX: t.minX, minY: t.minY, maxX: t.maxX, maxY: t.maxY,
            baseScale: t.baseScale, offsetX: t.offsetX, offsetY: t.offsetY,
            panX: t.panX, panY: t.panY, currentScale: t.currentScale, baseCssScale: t.baseCssScale,
            scrollLeft: t.scrollLeft, scrollTop: t.scrollTop, cssWidth: t.cssWidth, cssHeight: t.cssHeight,
            // 选中/hover
            selectedPartId: t.selectedPartId, hoveredPartId: t.hoveredPartId,
            selectedFocus: t.selectedFocus, hoveredFocus: t.hoveredFocus
          }))
        });
      }
      function persistNow() { try { localStorage.setItem(STORAGE_KEY, serializeTabs()); } catch (e) { console.warn('保存 tabs 失败', e); } }
      function tryRestore() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY); if (!raw) return false;
          const obj = JSON.parse(raw);
          if (!obj || !Array.isArray(obj.tabs)) return false;
          tabs = obj.tabs.map(t => Object.assign({
            __id: t.id || tabIdSeq++,
            data: null, minX: 0, minY: 0, maxX: 0, maxY: 0, baseScale: 1, offsetX: 0, offsetY: 0, parts: [], pointsParts: [], solutionLines: [], partMeta: [], hoveredPartId: null, selectedPartId: null, hoveredFocus: null, selectedFocus: null, panX: 0, panY: 0, currentScale: 1, baseCssScale: 1, cssWidth: null, cssHeight: null, scrollLeft: 0, scrollTop: 0
          }, t));
          activeTabIndex = Math.min(Math.max(0, obj.active || 0), tabs.length - 1);
          tabs.forEach(rebuildDerivedForTab);
          return true;
        } catch (e) { console.warn('恢复失败', e); return false; }
      }
      function clearPersist() { localStorage.removeItem(STORAGE_KEY); }
      function makeEmptyState(name = '未命名') { return { name, data: null, minX: 0, minY: 0, maxX: 0, maxY: 0, baseScale: 1, offsetX: 0, offsetY: 0, parts: [], pointsParts: [], solutionLines: [], partMeta: [], hoveredPartId: null, selectedPartId: null, hoveredFocus: null, selectedFocus: null, panX: 0, panY: 0, currentScale: 1, baseCssScale: 1, cssWidth: null, cssHeight: null, scrollLeft: 0, scrollTop: 0 }; }
      function captureCurrentIntoTab(t) { if (!t) return; const rect = canvas.getBoundingClientRect(); Object.assign(t, { data, minX, minY, maxX, maxY, baseScale, offsetX, offsetY, parts: [...parts], pointsParts: [...pointsParts], solutionLines: [...solutionLines], partMeta: [...partMeta], hoveredPartId, selectedPartId, hoveredFocus, selectedFocus, panX, panY, currentScale, baseCssScale, cssWidth: rect.width, cssHeight: rect.height, scrollLeft: canvasWrap.scrollLeft, scrollTop: canvasWrap.scrollTop }); }
      function rebuildDerivedForTab(t) { if (!t || !t.data) return; const raw = t.data; const mkHue = p => hueFromString((p.part_name || '') + (p.part_id ?? '')); const lineCandidates = (raw.part && Array.isArray(raw.part.line_candidates)) ? raw.part.line_candidates.map(p => { const ws = (p.lines || []).map(l => l.weight); const minW = ws.length ? Math.min(...ws) : 0; const maxW = ws.length ? Math.max(...ws) : 0; return { ...p, minW, maxW, hue: mkHue(p) }; }) : []; const pointCandidates = (raw.part && Array.isArray(raw.part.point_candidates)) ? raw.part.point_candidates.map(p => { const ws = (p.points || []).map(pt => pt.weight); const minW = ws.length ? Math.min(...ws) : 0; const maxW = ws.length ? Math.max(...ws) : 0; return { ...p, minW, maxW, hue: mkHue(p) }; }) : []; const solLines = (raw.solution && Array.isArray(raw.solution.lines)) ? raw.solution.lines.map((ln, idx) => ({ ...ln, __idx: idx })) : []; const metaMap = new Map(); function addM(p, type) { const id = p.part_id ?? (p.part_name || ''); if (!metaMap.has(id)) metaMap.set(id, { part_id: p.part_id, part_name: p.part_name || '', hue: p.hue, lineCount: 0, pointCount: 0, minW: Infinity, maxW: -Infinity }); const m = metaMap.get(id); m.hue = p.hue; if (type === 'line') { const cnt = (p.lines || []).length; m.lineCount += cnt; if (isFinite(p.minW)) m.minW = Math.min(m.minW, p.minW); if (isFinite(p.maxW)) m.maxW = Math.max(m.maxW, p.maxW); } else { const cnt = (p.points || []).length; m.pointCount += cnt; if (isFinite(p.minW)) m.minW = Math.min(m.minW, p.minW); if (isFinite(p.maxW)) m.maxW = Math.max(m.maxW, p.maxW); } } lineCandidates.forEach(p => addM(p, 'line')); pointCandidates.forEach(p => addM(p, 'point')); t.parts = lineCandidates; t.pointsParts = pointCandidates; t.solutionLines = solLines; t.partMeta = Array.from(metaMap.values()).map(m => ({ ...m, minW: isFinite(m.minW) ? m.minW : 0, maxW: isFinite(m.maxW) ? m.maxW : 0 })); }
      function snapshot() { if (activeTabIndex < 0) return; const t = tabs[activeTabIndex]; t.scrollLeft = canvasWrap.scrollLeft; t.scrollTop = canvasWrap.scrollTop; const rect = canvas.getBoundingClientRect(); t.cssWidth = rect.width; t.cssHeight = rect.height; Object.assign(t, { data, minX, minY, maxX, maxY, baseScale, offsetX, offsetY, parts, pointsParts, solutionLines, partMeta, hoveredPartId, selectedPartId, hoveredFocus, selectedFocus, panX, panY, currentScale, baseCssScale }); }
      function apply(t) { data = t.data; minX = t.minX; minY = t.minY; maxX = t.maxX; maxY = t.maxY; baseScale = t.baseScale; offsetX = t.offsetX; offsetY = t.offsetY; parts = t.parts; pointsParts = t.pointsParts; solutionLines = t.solutionLines; partMeta = t.partMeta; hoveredPartId = t.hoveredPartId; selectedPartId = t.selectedPartId; hoveredFocus = t.hoveredFocus; selectedFocus = t.selectedFocus; panX = t.panX; panY = t.panY; currentScale = t.currentScale; baseCssScale = t.baseCssScale; if (t.cssWidth && t.cssHeight) { canvas.style.width = t.cssWidth + 'px'; canvas.style.height = t.cssHeight + 'px'; } setTimeout(() => { canvasWrap.scrollLeft = t.scrollLeft || 0; canvasWrap.scrollTop = t.scrollTop || 0; applyPanTransform(); }, 0); }
      function updateTabBar() {
        tabBar.querySelectorAll('.tab').forEach(n => n.remove());
        tabs.forEach((t, i) => {
          const el = document.createElement('div');
          el.className = 'tab';
          el.draggable = true;
          if (!t.__id) t.__id = tabIdSeq++;
          el.dataset.id = t.__id;
          const isActive = i === activeTabIndex;
          el.style.cssText = 'display:flex;align-items:center;gap:6px;padding:4px 10px;border:1px solid ' + (isActive ? '#2684ff' : '#d0d5db') + ';background:' + (isActive ? '#e7f1ff' : '#fafbfc') + ';border-radius:6px;font-size:12px;cursor:pointer;position:relative;user-select:none;';
          const partCount = (t.partMeta || []).length || 0;
          const solCount = (t.solutionLines || []).length || 0;
          const boxCount = (t.data && Array.isArray(t.data.obstacle_box) ? t.data.obstacle_box.length : 0);
          const barrierCount = (t.data && Array.isArray(t.data.barrier_line) ? t.data.barrier_line.length : 0);
          const statsTitle = `parts: ${partCount}\nsolution: ${solCount}\nboxes: ${boxCount}\nbarriers: ${barrierCount}`;
          el.title = statsTitle;
          el.innerHTML = '<span class="tab-name" style="max-width:160px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">' + (t.name || '未命名') + '</span><span class="tab-close" title="关闭" style="font-weight:600;color:#888;">×</span>';
          el.addEventListener('click', ev => { if (ev.target.classList.contains('tab-close')) { closeTab(i); } else { switchTab(i); } });
          // 双击重命名 -> 悬浮面板
          el.addEventListener('dblclick', ev => { ev.stopPropagation(); openRenameFloating(t, el, i); });
          // 拖拽排序（用 id）
          el.addEventListener('dragstart', e => { e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', String(t.__id)); el.classList.add('dragging-tab'); });
          el.addEventListener('dragover', e => { e.preventDefault(); const draggingEl = tabBar.querySelector('.tab.dragging-tab'); if (!draggingEl || draggingEl === el) return; const rect = el.getBoundingClientRect(); const mid = rect.left + rect.width / 2; if (e.clientX < mid) { tabBar.insertBefore(draggingEl, el); } else { const next = el.nextSibling; tabBar.insertBefore(draggingEl, next); } });
          el.addEventListener('dragend', () => { const orderedIds = []; tabBar.querySelectorAll('.tab').forEach(tb => { if (tb.id === 'addTabBtn') return; const id = parseInt(tb.dataset.id, 10); if (!isNaN(id)) orderedIds.push(id); }); const newOrder = []; orderedIds.forEach(id => { const f = tabs.find(tt => tt.__id === id); if (f) newOrder.push(f); }); if (newOrder.length === tabs.length) { const activeId = tabs[activeTabIndex]?.__id; tabs = newOrder; activeTabIndex = Math.max(0, tabs.findIndex(tt => tt.__id === activeId)); updateTabBar(); persistNow(); } document.querySelectorAll('.dragging-tab').forEach(n => n.classList.remove('dragging-tab')); });
          // 悬浮重命名面板实现
          let renamePanel = null;
          function openRenameFloating(tabObj, anchorEl) { closeRenamePanel(); const r = anchorEl.getBoundingClientRect(); renamePanel = document.createElement('div'); renamePanel.style.cssText = 'position:fixed;z-index:9999;left:' + (r.left) + 'px;top:' + (r.bottom + 4) + 'px;background:#fff;border:1px solid #ccc;box-shadow:0 2px 8px rgba(0,0,0,.15);padding:6px 8px;border-radius:6px;font-size:12px;display:flex;gap:6px;align-items:center;'; renamePanel.innerHTML = '<input type="text" style="width:150px;padding:2px 4px;font-size:12px;" value="' + (tabObj.name || '未命名').replace(/"/g, '&quot;') + '" /> <button style="padding:2px 8px;">保存</button><button style="padding:2px 8px;">取消</button>'; document.body.appendChild(renamePanel); const input = renamePanel.querySelector('input'); const [btnSave, btnCancel] = renamePanel.querySelectorAll('button'); const commit = () => { tabObj.name = input.value.trim() || '未命名'; updateTabBar(); persistNow(); closeRenamePanel(); }; const cancel = () => closeRenamePanel(); input.addEventListener('keydown', e => { if (e.key === 'Enter') commit(); else if (e.key === 'Escape') cancel(); }); btnSave.addEventListener('click', commit); btnCancel.addEventListener('click', cancel); setTimeout(() => input.focus(), 0); }
          function closeRenamePanel() { if (renamePanel) { renamePanel.remove(); renamePanel = null; } }
          window.addEventListener('mousedown', e => { if (renamePanel && !renamePanel.contains(e.target) && !e.target.closest('.tab')) closeRenamePanel(); }, true);
          tabBar.insertBefore(el, addTabBtn);
        });
      }
      function switchTab(i) { if (i === activeTabIndex || i < 0 || i >= tabs.length) return; snapshot(); activeTabIndex = i; apply(tabs[i]); if (tabs[i].data) updateHeader(); else headerTitle.textContent = '未加载数据 — 拖拽或粘贴 JSON 以开始'; syncBackingStoreToCss(); render(); updateTabBar(); persistNow(); }
      function closeTab(i) { if (i < 0 || i >= tabs.length) return; const wasActive = i === activeTabIndex; tabs.splice(i, 1); if (!tabs.length) { activeTabIndex = -1; data = null; headerTitle.textContent = '未加载数据 — 拖拽或粘贴 JSON 以开始'; render(); updateTabBar(); persistNow(); return; } if (wasActive) { activeTabIndex = Math.max(0, i - 1); apply(tabs[activeTabIndex]); if (tabs[activeTabIndex].data) updateHeader(); else headerTitle.textContent = '未加载数据 — 拖拽或粘贴 JSON 以开始'; render(); } else if (i < activeTabIndex) { activeTabIndex--; } updateTabBar(); persistNow(); }
      function openNewTab(json, fileName) { const name = fileName || (json && json.schema_name) || '未命名'; if (activeTabIndex === -1) { const t = makeEmptyState(name); t.__id = tabIdSeq++; tabs = [t]; activeTabIndex = 0; apply(t); setupFromData(json); t.name = name; captureCurrentIntoTab(t); updateTabBar(); persistNow(); return; } snapshot(); const t = makeEmptyState(name); t.__id = tabIdSeq++; tabs.push(t); activeTabIndex = tabs.length - 1; apply(t); setupFromData(json); t.name = name; captureCurrentIntoTab(t); updateTabBar(); persistNow(); }
      addTabBtn.addEventListener('click', () => { openNewTab({}, '新标签'); });
      // 清空按钮（仅保留清空逻辑），并且默认自动恢复
      const clearBtn = document.getElementById('clearTabsBtn');
      if (clearBtn) clearBtn.addEventListener('click', () => { if (!confirm('确定清空所有标签页并清除保存记录?')) return; tabs = []; activeTabIndex = -1; data = null; clearPersist(); render(); updateTabBar(); headerTitle.textContent = '未加载数据 — 拖拽或粘贴 JSON 以开始'; });
      // 导出 PDF 按钮
      const exportBtn = document.getElementById('exportPdfBtn');
      if (exportBtn) {
        exportBtn.addEventListener('click', async () => {
          if (!tabs.length) { alert('没有可导出的标签页'); return; }
          if (exportBtn.__busy) return;
          exportBtn.__busy = true;
          const originalText = exportBtn.textContent;
          exportBtn.textContent = '导出中...';
          exportBtn.style.opacity = '0.6';
          try {
            // 动态获取 jsPDF
            const { jsPDF } = window.jspdf || {};
            if (!jsPDF) { alert('jsPDF 未加载'); return; }
            // 标题中文方案：使用离屏 canvas 渲染文字转成图片嵌入 PDF，避免字体缺失问题
            function renderTitleImage(title, maxW) {
              const fontPx = 14; // 接近 UI 字号
              const paddingX = 4, paddingY = 2;
              const cvs = document.createElement('canvas');
              const ctx2 = cvs.getContext('2d');
              ctx2.font = fontPx + 'px "Microsoft YaHei", "PingFang SC", "Heiti SC", Arial, sans-serif';
              // 过长截断
              function fit(str) {
                if (ctx2.measureText(str).width <= maxW) return str;
                const ell = '...';
                let base = str;
                while (base.length > 0) {
                  base = base.slice(0, -1);
                  if (ctx2.measureText(base + ell).width <= maxW) return base + ell;
                }
                return ell;
              }
              const fitted = fit(title);
              const w = Math.ceil(ctx2.measureText(fitted).width);
              cvs.width = w + paddingX * 2;
              cvs.height = fontPx + paddingY * 2 + 2;
              ctx2.font = fontPx + 'px "Microsoft YaHei", "PingFang SC", "Heiti SC", Arial, sans-serif';
              ctx2.fillStyle = '#000';
              ctx2.textBaseline = 'top';
              ctx2.fillText(fitted, paddingX, paddingY);
              return { dataUrl: cvs.toDataURL('image/png'), w: cvs.width, h: cvs.height };
            }
            // A4 纵向尺寸 (pt)
            const pdf = new jsPDF('p', 'pt', 'a4');
            const pageW = pdf.internal.pageSize.getWidth();
            const pageH = pdf.internal.pageSize.getHeight();
            const margin = 24; // 页边距
            const titleGap = 6; // 标题与图像之间空隙
            const scaleDown = (imgW, imgH, maxW, maxH) => {
              let r = Math.min(maxW / imgW, maxH / imgH, 1);
              return { w: imgW * r, h: imgH * r, r };
            };
            const activeBefore = activeTabIndex;
            snapshot(); // 先保存当前活动页
            for (let i = 0; i < tabs.length; i++) {
              const t = tabs[i];
              if (!t.data) continue; // 跳过空的
              // 切换到该 tab 并渲染
              activeTabIndex = i;
              apply(t);
              render();
              await new Promise(r => setTimeout(r, 30)); // 让浏览器渲染完成
              const rect = canvas.getBoundingClientRect();
              const dataUrl = canvas.toDataURL('image/png');
              const availableW = pageW - margin * 2;
              const titleRaw = (t.name || '未命名') + (t.data && t.data.schema_name ? ' — ' + t.data.schema_name : '');
              const titleImg = renderTitleImage(titleRaw, availableW);
              const availableH = pageH - margin * 2 - titleImg.h - titleGap;
              const scaled = scaleDown(rect.width, rect.height, availableW, availableH);
              if (i !== 0) pdf.addPage();
              // 标题图片 (左对齐; 如需居中可改 (pageW - titleImg.w)/2 )
              pdf.addImage(titleImg.dataUrl, 'PNG', margin, margin, titleImg.w, titleImg.h);
              const imgX = margin + (availableW - scaled.w) / 2;
              const imgY = margin + titleImg.h + titleGap + (availableH - scaled.h) / 2;
              pdf.addImage(dataUrl, 'PNG', imgX, imgY, scaled.w, scaled.h);
              exportBtn.textContent = `导出中 ${i + 1}/${tabs.length}`;
            }
            // 恢复之前的活动页
            if (activeBefore >= 0 && activeBefore < tabs.length) {
              activeTabIndex = activeBefore;
              apply(tabs[activeBefore]);
              render();
            }
            const ts = new Date();
            const pad = n => String(n).padStart(2, '0');
            const fileName = `tabs_export_${ts.getFullYear()}${pad(ts.getMonth() + 1)}${pad(ts.getDate())}_${pad(ts.getHours())}${pad(ts.getMinutes())}${pad(ts.getSeconds())}.pdf`;
            pdf.save(fileName);
            exportBtn.textContent = originalText;
          } catch (e) {
            console.error(e);
            alert('导出失败: ' + e.message);
          } finally {
            exportBtn.__busy = false;
            exportBtn.style.opacity = '';
            exportBtn.textContent = originalText;
            // 恢复标签栏 UI
            updateTabBar();
          }
        });
      }
      // 页面初始化自动恢复
      if (tryRestore() && tabs.length) { apply(tabs[activeTabIndex]); render(); updateTabBar(); } else { activeTabIndex = -1; tabs = []; data = null; headerTitle.textContent = '未加载数据 — 拖拽或粘贴 JSON 以开始'; render(); updateTabBar(); }
      updateTabBar();
      // hook 全局
      const originalSetData = window.__vis.setData; window.__vis.openNewTab = openNewTab; window.__vis.switchTab = switchTab; window.__vis.closeTab = closeTab; window.__vis.getTabs = () => tabs.slice(); window.__vis.setData = (d) => openNewTab(d, (d && d.schema_name) || '未命名');
      // 暴露一个便捷函数
      window.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === 'w') { // Ctrl+W 关闭当前
          closeTab(activeTabIndex); e.preventDefault();
        }
      });
    })();
  </script>
</body>

</html>